# 泛型

泛型只能使用复合数据类型,泛型引用和创建两端，给出的泛型变量必须相同。

- 定义

  - 泛型类定义

    泛型类中使用泛型

    - 成员类型
    - 返回值和参数类型
    - 局部变量的引用上
  
    ```
  Class<T> type
    ```
  
  - 把泛型定义在方法上
  
    ```
    public <T> T add(T x, T y){ 
  }
    ```

  - 泛型接口
  
    ```
    public interface 接口名<泛型类型1…>
    ```
  
    
  
  子类的泛型个数>=父类的泛型个数
  
  继承过来的泛型可以不写吗?可以,泛型擦除,变成Object类型

PECS原则

1.  “?”不能添加元素
2.  “? extends T”也不能添加元素
3.  “? super T”能添加元素

# 设计模式

1. 单例设计模式

> 1. 构造方法私有化：外界不可以通过 new 关键字再自行创建对象
>
> 2. 内部提供一个对象(用private static 修饰)
> 3. 在类的内部提供一个获取对象的方法

2. 适配器模式

   所谓的适配器模式是指当一个类要实现一个接口或者继承一个抽象类的时候，必须覆写接口或抽象类中所有方法，但多数情况下，子类真正需要的只有一个或几个方法，而其余的方法为了满足语法的要求，也必须在子类中进行覆写，所以在它们之间加一个适配器

   创建一普通类Adapter（适配器），继承对应抽象类或者实现对应接口，覆写其所有抽象类，但是方法体为空，原本要继承抽象类或者接口的子类，此时可以直接继承适配器类即可

3. 工厂模式

4. 装饰器模式

   1. 创建一个接口.
   2. 创建实现接口的实体类。
   3. 创建实现了接口的装饰类。
   4. 使用装饰类

