# 面向对象编程

## 1. 面向对象四大基本特性

- 封装
- 继承
- 多态
- 抽象

## 2. 对象和类

> - **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
> - **类**：类是一个模板，它描述一类对象的行为和状态。

- 构造方法

  > 创建对象的时候调用

  要求：

  1. 没有返回值，连void都没有
  2. 方法名称和类名称一样
  3. 自己写了构造方法，系统将不再调用构造方法

  用处：

  1. 能创建对象
  2. 给属性赋值

## 3. 访问权限关键字

- private
- default
- protected
- public

![ä¿®é¥°ç¬¦](https://img-blog.csdn.net/20171125114912312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHFub2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 4. 匿名对象

> 没有名字的对象

使用场景：

- 当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。
- 匿名对象可以作为实际参数进行传递。

##  5. 值传递和引用传递

1. 值传递对形参的修改不会影响实参
2. 引用类型传引用，形参和实参指向同一个内存地址(同一个对象)，所以对参数的修改会影响到实际的对象。
3. String，Integer，Double等immutable(不可改变)的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。

> public void swap(int a，int b){
>
> ​	int temp = a；
>
> ​	a = b;
>
> ​	b=temp;
>
> }
>
> 调用该方法时只会在方法内部完成交换。

## 6. 垃圾回收机制

>   垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。
>
> ​    注意：垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。但不能说是回收对象，可以理解为一种文字游戏。

### 7. Java的内存

1. 程序计数器

   > **从上面的介绍中我们知道程序计数器主要有两个作用：**
   >
   > 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   > 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

   **注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

2. Java虚拟机栈

> **Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** **局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。





