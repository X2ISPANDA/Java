# 面向对象编程

## 1. 面向对象四大基本特性

- 封装
- 继承
- 多态
- 抽象

## 2. 对象和类

> - **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
> - **类**：类是一个模板，它描述一类对象的行为和状态。

- 构造方法

  > 创建对象的时候调用

  要求：

  1. 没有返回值，连void都没有
  2. 方法名称和类名称一样
  3. 自己写了构造方法，系统将不再调用构造方法

  用处：

  1. 能创建对象
  2. 给属性赋值

## 3. 访问权限关键字

- private
- default
- protected
- public

![ä¿®é¥°ç¬¦](https://i.loli.net/2020/06/24/M9Fk1SfOVoL5zZJ.png)

## 4. 匿名对象

> 没有名字的对象

使用场景：

- 当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。
- 匿名对象可以作为实际参数进行传递。

##  5. 值传递和引用传递

1. 值传递对形参的修改不会影响实参
2. 引用类型传引用，形参和实参指向同一个内存地址(同一个对象)，所以对参数的修改会影响到实际的对象。
3. String，Integer，Double等immutable(不可改变)的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。

> public void swap(int a，int b){
>
> ​	int temp = a；
>
> ​	a = b;
>
> ​	b=temp;
>
> }
>
> 调用该方法时只会在方法内部完成交换。



## 6. 封装

封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

好处：

1.  将变化隔离。
2.  便于使用。
3.  提高重用性。
4.  提高安全性。

封装原则：

1. 将不需要对外提供的内容都隐藏起来。
2. 把属性都隐藏，提供公共方法对其访问。如，getXXX，setXXX。

注意事项：

- 私有仅仅是封装的一种体现而已。
- private关键字：是一个权限修饰符，用于修饰成员(成员变量和成员函数)，被私有化的成员只在本类中有效。
- 常用场景之一：将成员变量私有化，对外提供对应的set、get方法对其进行访问，提高对数据访问的安全性。

## 7. this关键字

> this代表其所在函数所属对象的引用。换言之，this代本类对象的引用。
>
> 当成员变量和局部变量重名，可以用关键字this来区分，this就是所在函数所属对象的引用。
>
> 简单说，哪个对象调用了this所在的函数，this就代表哪个对象。一般方法调用默认加this。（方法被哪个对象调用，this就代表那个对象）

<font color=red style="background-color:yellow;"> 可以通过this()调用类中的构造方法，必须放在第一行,普通方法中不能调用。</font>

<p style="color:red;">静态方法里不可以使用this</p>
## 8. static关键字

1. static可以修饰什么

   1. 属性(静态属性、静态变量、类变量)
   2. 一般方法(静态方法、类方法)
   3. 游离语句块(静态语句代码块)
   4. 内部类

2. static关键字特点

   - 随着类的加载而加载
   
   - 优先于对象存在
   
   - 被类的所有对象共享
   
   - 这也是我们判断是否使用静态关键字的条件
   
   - 可以通过类名调用
   
3. static关键字注意事项

   - 在静态方法中是没有super和this关键字的
   - 静态方法只能访问静态的成员变量和静态的成员方法
   - 在Java中规定不能将方法体内的局部变量声明为static
   
4. 构造方法和成员变量初始化顺序
   
   执行父类静态代码 执行子类静态代码 初始化父类成员变量（我们常说的赋值语句） 初始化父类构造函数 初始化子类成员变量 初始化子类构造函数
   
   **父类静态游离块 > 子类静态游离块 > 父类游离块 > 父类构造函数 > 子类游离块 > 子类构造函数**
   
   <p style="color:red;font-size:20px">所有的变量初始化完，才会执行构造方法</p>

```java
class A2{
    B2 b2 = new B2();
    static{
        System.out.println("A static");
    }
    public A2() {
        System.out.println("A2()");
    }
}
class B2{
    C2 c2 = new C2();
    D2 d2 = new D2();
    static{
        System.out.println("B static");
    }
    public B2() {
        System.out.println("B2()");
    }
}
class C2{
    static{
        System.out.println("C static");
    }
    public C2() {
        System.out.println("C2()");
    }
}
class D2{
    static{
        System.out.println("D static");
    }
    public D2() {
        System.out.println("D2()");
    }
}
public class VarTest {
    public static void main(String[] args) {
        A2 a2 = new A2();
    }
}
```

输出结果为：

```A static
B static
C static
C2()
D static
D2()
B2()
A2()
```

静态成员与普通成员类的加载区别

在类的加载过程中，静态成员类的对象，会优先加载；而普通成员类的对象则是使用的时候才回去加载。

```java
class A3{
    B3 b3 = new B3();
    static C3 c4 = new C3();
    static{
        System.out.println("A3");
    }
}
class B3{
    static{
        System.out.println("B3");
    }
}
class C3{
    static{
        System.out.println("C3");
    }
}
public class StaticTest {
    public static void main(String[] args) {
        A3 a3 = new A3();
    }
}
```

输出:

```
C3
A3
B3
```

*总结*

第一点，所有的类都会优先加载基类
第二点，静态成员的初始化优先
第三点，成员初始化后，才会执行构造方法
第四点，静态成员的初始化与静态块的执行，发生在类加载的时候。
第四点，类对象的创建以及静态块的访问，都会触发类的加载。

*类构造方法的顺序*

```java
class A{
    public A() {
        System.out.println("A");
    }
}
class B extends A{
    public B() {
        System.out.println("B");
    }
}
class C extends B {
    private D d1 = new D("d1");
    private D d2 = new D("d2");
    public C() {
        System.out.println("C");
    }
}
class D {
    public D(String str) {
        System.out.println("D "+str);
    }
}
public class ExtendTest {
    public static void main(String[] args) {
        C c = new C();
    }
}
```

执行结果：

```A
B
D d1
D d2
C
```

因此可以得出结论：

- 首先会调用基类的构造方法
- 其次，调用成员的构造方法
- 最后，调用自己的构造方法

## 9. 继承

> 在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。
>
> 通过 extends 关键字让类与类之间产生继承关系。
>
> 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。

注意事项：

- 子类可以直接访问父类中的非私有的属性和行为。
- 子类无法继承父类中私有的内容。
- 父类怎么来的？共性不断向上抽取而来的。
- 父类的构造方法不可以继承

***继承的特点***

1．在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。

![1500704447701](https://i.loli.net/2020/06/24/FqWIKXQuZv62bTJ.png)

2．多个类可以继承一个父类，例如下面这种情况是允许的。

![1500704467099](https://i.loli.net/2020/06/24/6anqby3NfxcI28E.png)

3．在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。例如下面这种情况是允许的。

![1500704487847](C:%5CUsers%5Cxmy32%5CDesktop%5C1500704487847.png)

4．在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的示例中，B类是A类的子类，同时又是C类的父类。

Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 原因：因为多继承容易出现问题。两个父类中有相同的方法，子类到底要执行哪一个是不确定的。

## 10. super关键字

子类想调用父类提供的方法或属性用super关键字。

作用：

1. 调用父类中构造方法用super()；必须放在第一行
2. 调用父类中的普通方法super.普通方法()；
3. 调用父类中的属性super.属性；

## 11. 可变参数

> 可变长参数的底层是数组，访问的方式用for循环。

使用规则：

1. 在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，则选择固定参数的方法。
2. 如果要调用的方法可以和两个可变参数匹配，则出现错误。
3. 一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数。

## 12. final关键字

作用：

1. 声明类：声明类的时候表示该类不能再被继承
2. 声明方法：声明方法的时候表示该方法不能被子类重写
3. 声明变量：声明变量的时候表示该变量变成常量（常量：一旦赋值之后，里面的值不能再变）
<span style="color:red;background-color:yellow">但是用final修饰复合数据类型的时候，引用不能重新赋值，但里面的内容可以重新赋值。</span>

## 13. 垃圾回收机制

>   垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。
>
> ​    注意：垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。但不能说是回收对象，可以理解为一种文字游戏。

## 14. Java的内存

1. 程序计数器

   > **从上面的介绍中我们知道程序计数器主要有两个作用：**
   >
   > 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   > 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

   **注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

2. Java虚拟机栈

> **Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** **局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

## 15. 语句块

- 普通代码块

  > 写在方法里面的
  >
  > {
  >
  > 
  >
  > }

- 构造块

  > 写在类里面的
  >
  > {    }
  >
  > 每次 创建对象都会执行一次

- 静态块

  > 在类中定义的，使用static修饰的代码块，称为静态代码块，它是属于类的，在类加载时就自动执行。
  >
  > static{   }
  >
  > 只会在加载类时执行一次

## 16. 内部类与外部类

定义：将一个类定义在另一个类的里面，里面那个类就称为内部类（内置类，嵌套类）。

内部类不仅可以在类中定义,还可以在方法中定义.

访问特点：<span style="color:red;background-color:yellow">内部类可以直接访问外部类中的成员，包括私有成员。而外部类要访问内部类中的成员必须要建立内部类的对象。</span>

内部类引用外部类对象:外部类名.this

内部类的分类

1. 成员内部类

   - 非静态内部类
   - 静态内部类
   - 匿名内部类

2. 方法内部类

   方法内部类不能用puclic修饰.只能通过在该方法里定义内部类的对象,直接调用内部类的方法

3. 匿名内部类

   定义：就是内部类的简化写法。 前提：内部类必须继承或实现一个外部类或者接口,但两者不可兼得。 格式：new 外部类名或者接口名(){覆盖类或者接口中的代码，(也可以自定义内容。)} 简单理解：就是建立一个带内容的外部类或者接口的子类匿名对象。

   内部类定义在成员位置上，可以被private、static成员修饰符修饰。被static修饰的内部类只能访问外部类中 的静态成员。
   
   如果内部类中定义了静态成员，该内部类也必须是静态的！
   
   - 继承式
   - 接口式
   - 参数式
   
   
   
   **注意事项**
   
   在使用匿名内部类的过程中，我们需要注意如下几点：
   
   1. 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。
   
   2. 匿名内部类中是不能定义构造方法的。
   3. 匿名内部类中不能存在任何的静态成员变量和静态方法。
   4. 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。
   5. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
   6. 当所在的方法的形参需要被内部类里面使用时，该形参必须为final。

## 17. 抽象

1. 抽象类

   Java允许在定义方法时不写方法体，不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰。

   Java中可以定义没有方法体的方法，该方法的具体实现由子类完成，该方法称为抽象方法，包含抽象方法的类就是抽象类。

   <span style="color:red;background-color:purple">抽象类不一定有抽象方法,包含抽象方法的类一定是抽象类.</span>

   抽象类不可以new创建对象,但是抽象类有构造方法.

2. 抽象类的使用
   - 定义一个子类继承抽象类
   - 复写抽象类中所有的抽象方法



## 18. 接口

> 当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口。
>
> 注意点:
>
> 1. 接口没有构造方法
>
> 2. 接口中的方法均为公共访问的抽象方法
>
> 3. 接口中无法定义普通的成员变量
> 4. 接口不能继承抽象类
> 5. 接口里可以有静态方法和普通方法
>
> 
>
> 抽象类和接口的异同点？
>
> 相同点：都是不断向上抽取而来的。
>
> 不同点：
>
> 1. 抽象类需要被继承，而且只能单继承。接口需要被实现，而且可以多实现。
> 2. 抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法。接口中只能定义抽象方法，必须由子类去实现。
> 3. 抽象类的继承，是is a关系，定义该体系的基本共性内容。接口的实现是like a关系

****

***接口的作用***

1、为了弥补 Java 的单继承的局限性

2、接口的出现扩展了功能。

3、接口的出现降低了耦合性

## 19. 多态

> 定义：某一类事物的多种存在形态。

<span style="font-size:24px;color:red;background-color:yellow">最终多态体现为父类引用变量可以指向子类对象</span>

### 多态的实现

分为两种:

- 向上转型
- 向下转型

<span style="font-size:24px;color:red;background-color:yellow">同一个父类的方法会被不同的子类重写。在调用方法时，调用的是各个子类重写后的方法。</span>



***当子父类中出现同名的成员变量时***

> 多态调用该变量时：
> 编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
> 运行时期：也是调用引用型变量所属的类中的成员变量。
> 简单记：编译和运行都参考等号的左边。编译运行看左边。



## 20. instanceof关键字

> 判断某个对象是否属于某个类型

